require 'open-uri'

puts <<~EO_USAGE
  # DON'T MODIFY
  # generated by
  # rails runner lib/seed_generator.rb > db/seeds.rb
EO_USAGE

Product::BUSINESS_SIZES.each do |business|
  tag_b = ActsAsTaggableOn::Tag.find_by(name: business)
  ActsAsTaggableOn::Tag.create!(name: business) if tag_b.nil?
end

users = [
  { email: "sarah@gmail.com", password: "password" },
  { email: "bob@gmail.com", password: "azerty" },
  { email: "yan@gmail.com", password: "password" }
]

users.each do |el|
  user = User.new(
      :email                 => el[:email],
      :password              => el[:password],
      :password_confirmation => el[:password]
    )
  user.save
      puts format(
      <<~EO_PRODUCT_CREATE,
        user = User.find_by(%<find_args>s)
        user = User.create!(%<create_args>s) if user.nil?
        user.update!(%<update_args>s)
        user = nil
      EO_PRODUCT_CREATE
      find_args: {email: el[:email]},
      create_args: {email: el[:email],password: el[:password],password_confirmation: el[:password]},
      update_args: {}
    )
end

categories = [
  "bookkeeping",
  "user experience",
  "developer tools",
  "marketing",
  "CRM",
  "design tools",
  "productivity",
  "analytics"
]

categories.each do |category|
  puts format(
    <<~EO_PRODUCT_CREATE,
      tag = ActsAsTaggableOn::Tag.find_by(name: "%<category>s")
      ActsAsTaggableOn::Tag.create!(name: "%<category>s") if tag.nil?
    EO_PRODUCT_CREATE
    category: category
  )
end

categories.each do |category|
  html_file = URI.open("https://www.producthunt.com/search?q=#{category}").read
  html_doc = Nokogiri::HTML(html_file)

  apollo_state = JSON.parse(
    html_doc
      .search("#__NEXT_DATA__")
      .to_s
      .sub(/^[^{]+\{/, '{')
      .sub("</script>", "")
  ).dig("props", "apolloState")
  post_keys = apollo_state.keys.filter { |post_key| post_key =~ /Post\d+$/ }
  apollo_state_products = post_keys.map do |post_key|
    apollo_state[post_key].slice(
      "name",
      "tagline",
      "thumbnailImageUuid"
      # NOTE: other data that could be extracted
      # "alternativesCount",      # =>22,
      # "commentsCount",          # =>11,
      # "pricingType",            # =>nil,
      # "recommendedPostsCount",  # =>22,
      # "productState",           # =>"default",
      # "createdAt",              # =>"2019-03-26T06:00:00-07:00",
      # "featuredAt",             # =>"2019-03-26T06:00:00-07:00",
      # "updatedAt",              # =>"2021-11-20T14:45:37-08:00",
      # "disabledWhenScheduled",  # =>true,
      # "hasVoted",               # =>false,
      # "votesCount",             # =>196,
    )
  end

  html_doc
    .search("main h3")
    .reject { |h3| h3.search("a").length != 2 }
    .map { |h3|
    {
      ph_url: h3.search("a")[0]["href"],
      url: h3.search("a")[1]["href"],
      name: h3.text,
    } }
    .reject { |product| product[:name].empty? }
    .each do |args|
    response = Net::HTTP.get_response(URI.parse("https://www.producthunt.com#{args[:url]}"))
    args[:url] = response['location'].sub("?ref=producthunt", "")

    args = args.merge(ph_url: "https://www.producthunt.com#{args[:ph_url]}")

    categories = [category]
    product_page = URI.open(args[:ph_url]).read
    product_doc = Nokogiri::HTML(product_page)
    product_data = ProducthuntParser.parse_product_page(product_doc)

    # product_doc
    #   .search("main div")
    #   .to_a
    #   .filter { |div| !div.search("> span").empty? && div.search("> span").text == "" }
    #   .map do |product_doc_category| # not including any +1 +2
    #     categories << product_doc_category
    #   end

    thumbnail_uuid = apollo_state_products.find { |asprod| asprod["name"] == args[:name] }["thumbnailImageUuid"]
    image_url = "https://ph-files.imgix.net/#{thumbnail_uuid}" if thumbnail_uuid
    optional_args = "?auto=format&auto=compress&codec=mozjpeg&cs=strip&w=160&h=160&fit=crop&dpr=3%203x%22"
    image_url = "https://ph-files.imgix.net/#{thumbnail_uuid}#{optional_args}" if thumbnail_uuid
    args = args.merge(image_url: image_url) if image_url

    puts format(
      <<~EO_PRODUCT_CREATE,
        product = Product.find_by(%<find_args>s)
        product = Product.create!(%<create_args>s) if product.nil?
        product.update!(%<update_args>s)
        product.category_list.add("%<categories>s", parse: true)
        product.save!
        product = nil
      EO_PRODUCT_CREATE
      find_args: {name: args[:name], url: args[:url]},
      create_args: {name: args[:name], url: args[:url]},
      update_args: {bio: product_data[:bio], info: product_data[:info], image_url: args[:image_url]},
      categories: [category].join(", ")
    )
  rescue ActiveRecord::RecordInvalid => e
    puts e, "could not save that product, moving on"
    puts "for:", name, url
  end
end

## NEED TO SORT THIS OUT

#   lists = [
#     { name: "Bookkeeping Solutions", description: "Looking for free and low cost book keeping solutions for my cafe" },
#     { name: "Marketing Solutions", description: "Looking for free and low cost marketing keeping solutions for my cafe" },
#   ]

#   lists.each do |list|
#     list = List.new(
#         :name                => list[:name,
#         :password            => list[:description],
#       )
#     list.save
#   end

#   #have list id_1 id_2

#   solutions = [
#     {list_id: 1,  product_id:
#       products_samples = [(Product.tagged_by("bookkeeping").sample(10)]

#       product_samples.each do |product|
#         product.product_id
#       end


#     },
#     {list_id: 2,  product_id: sample(Product.tagged_by("marketing")},
# }
